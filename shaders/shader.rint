/*
#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable

struct Sphere {
    vec4 positionRadius; // xyz=position, w=radius
};

layout(binding = 3) buffer Spheres { Sphere spheres[]; };

hitAttributeEXT vec3 hitNormal;

void main() {
    vec3 rayOrigin = gl_WorldRayOriginEXT;
    vec3 rayDir = gl_WorldRayDirectionEXT;
    
    for(int i = 0; i < spheres.length(); i++) {
        Sphere sphere = spheres[i];
        vec3 center = sphere.positionRadius.xyz;
        float radius = sphere.positionRadius.w;
        
        vec3 oc = rayOrigin - center;
        float a = dot(rayDir, rayDir);
        float b = 2.0 * dot(oc, rayDir);
        float c = dot(oc, oc) - radius*radius;
        float disc = b*b - 4*a*c;
        
        if(disc >= 0) {
            float t = (-b - sqrt(disc)) / (2*a);
            if(t >= gl_RayTminEXT && t <= gl_RayTmaxEXT) {
                hitNormal = (rayOrigin + t*rayDir - center) / radius;
                reportIntersectionEXT(t, 0);
            }
        }
    }
}
*/

#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable

hitAttributeEXT vec3 hitNormal;

void main() {
    vec3 rayOrigin = gl_WorldRayOriginEXT;
    vec3 rayDir = gl_WorldRayDirectionEXT;
    
    // Hardcoded sphere
    vec3 center = vec3(0, 0, 0);
    float radius = 1.0;
    
    vec3 oc = rayOrigin - center;
    float a = dot(rayDir, rayDir);
    float b = 2.0 * dot(oc, rayDir);
    float c = dot(oc, oc) - radius*radius;
    float disc = b*b - 4*a*c;
    
    if(disc >= 0) {
        float t = (-b - sqrt(disc)) / (2*a);
        if(t >= gl_RayTminEXT && t <= gl_RayTmaxEXT) {
            hitNormal = (rayOrigin + t*rayDir - center) / radius;
            reportIntersectionEXT(t, 0);
        }
    }
}
