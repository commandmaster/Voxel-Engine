#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable

layout(binding = 3) buffer SphereBuffer 
{
    vec4 spheres[];
};

layout(binding = 1, rgba32f) uniform image2D storageImage;


struct HitInformation
{
    vec3 normal;
    bool debugHit;
};


hitAttributeEXT HitInformation attribs;


void main() {
    uint sphereIdx = gl_PrimitiveID;
    attribs.debugHit = false;

    vec4 sphere = spheres[sphereIdx];
    vec3 center = sphere.xyz;
    float radius = sphere.w;

    vec3 rayOrigin = gl_WorldRayOriginEXT;
    vec3 rayDir = gl_WorldRayDirectionEXT;
    
    vec3 oc = rayOrigin - center;
    float a = dot(rayDir, rayDir);
    float b = 2.0 * dot(oc, rayDir);
    float c = dot(oc, oc) - radius*radius;
    float disc = b*b - 4*a*c;
   
    if (disc >= 0.0)
    {
        float sqrtDisc = sqrt(disc);
        float t1 = (-b - sqrtDisc) / (2.0 * a);
        float t2 = (-b + sqrtDisc) / (2.0 * a);

        float t = min(t1, t2);
        if (t >= gl_RayTminEXT && t <= gl_RayTmaxEXT) 
        {
            attribs.normal = normalize(rayOrigin + t*rayDir - center);
            reportIntersectionEXT(t, 0);
            return;
        } 
        else if (t2 >= gl_RayTminEXT && t2 <= gl_RayTmaxEXT) 
        {
            t = t2;
            attribs.normal = normalize(rayOrigin + t*rayDir - center);
            reportIntersectionEXT(t, 0);
            return;
        }
    }


    attribs.debugHit = true;
    reportIntersectionEXT(10, 0);
}